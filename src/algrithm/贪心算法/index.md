

贪心算法并不真的能保证对于所有的题目，都能找到最优解，有可能只是较优解，或者是个解，或者是个不咋地的解

### 常见的问题

1. 集装箱装载问题

  有一艘货轮，它的载重量是定值。有很多货物装在集装箱内，每个集装箱的大小是一样的，但重量不一样。现在要求在保证安全的前提下，（也就是总的重量不能超过载重量，）尽量多的装集装箱，以使船上的集装箱数量最多。

  解法：那就按照从轻到重，先尽量选择轻的，轻的没了，再装重的。

  > 题目还可以升级：每个集装箱的货物重量不一样，价值也不一样，怎么装，在保证船安全的前提下，货物价值最高。（价值高才能卖更多的钱，所以光看集装箱的数量最多，意义比如价值最高。）这就不是贪心的范畴了，就要动态规划了。这也就是背包问题，背包总容量是一定的，每件商品占的空间不一样，价值不一样，怎么拿，使得既不超出背包总容量，又价值最高。

2. 找钱问题
   
   商店员工要给顾客找钱，总额是定的，每个面值的钱都有且不限量，（100，50，20，10，5，2，1），要求找的总的张数最少。

   解法：按最大额到最小额的次序，尽量先使用较大额的钱，并且保证不超过要找的钱，本级额度不行之后，再继续小额度。最后给的钱的张数就是最少的。

   原理：找钱是要保证最后既找的钱的总额是对的，又要张数最少。假设按照上面解法得到一种方案，使用的钱数量是 x，y，z，w，（按面额从大到小）。如果不选择这种方案，那意味着从某一级面额上要减少该级的数量（因为上面的解法对每一级面额都是尽量多的使用，所以有另外的解法，一定就只能从某一级开始减少该级的数量），减少了该级数量，而且必须保证总额还是不变的，那就势必要增加后面的面额的钱的数量，而且1张大面额钱 = n张小面额钱，前面减少了t张大面额，后面就要增加 n*t 张小面额，n*t大于1，则整体加起来，钱的数量一定是变大了，所以上面解法中就是最优的解法了。

   > 这里每个面额的钱都是不限量的，换个情况，每个面额的钱都是限量的，但是保证最后可以找够钱，那上面的解法依然有效。因为只要前面的钱少了一张，后面的钱就要多出好多张，整体上就增加了钱的数量，不是最优解。

3. 机器调度问题

4. 0/1背包问题

很经典，待详解