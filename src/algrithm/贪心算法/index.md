

贪心算法并不真的能保证对于所有的题目，都能找到最优解，有可能只是较优解，或者是个解，甚至是个不咋地的解。

### 常见的问题

1. 集装箱装载问题

  有一艘货轮，它的载重量是定值。有很多货物装在集装箱内，每个集装箱的大小是一样的，但重量不一样。现在要求在保证安全的前提下，（也就是总的重量不能超过载重量，）尽量多的装集装箱，以使船上的集装箱数量最多。

  解法：那就按照从轻到重，先尽量选择轻的，轻的没了，再装重的。

  > 题目还可以升级：每个集装箱的货物重量不一样，价值也不一样，怎么装，在保证船安全的前提下，货物价值最高。（价值高才能卖更多的钱，所以光看集装箱的数量最多，意义不如看价值最高。）这就不是贪心的范畴了，就要动态规划了。这也就是**0/1背包问题**:背包总容量是一定的，每件商品占的空间不一样，价值不一样，怎么拿，使得既不超出背包总容量，又价值最高。

2. 找钱问题
   
   商店员工要给顾客找钱，总额是定的，每个面值的钱都有且不限量，（100，50，20，10，5，2，1），要求找的总的张数最少。

   解法：按最大额到最小额的次序，尽量先使用较大额的钱，并且保证不超过要找的钱，本级额度不行之后，再继续小额度。最后给的钱的张数就是最少的。

   原理：找钱是要保证最后既找的钱的总额是对的，又要张数最少。假设按照上面解法得到一种方案，使用的钱数量是 x，y，z，w，（按面额从大到小）。如果不选择这种方案，那意味着从某一级面额上要减少该级的数量（因为上面的解法对每一级面额都是尽量多的使用，所以有另外的解法，一定就只能从某一级开始减少该级的数量），减少了该级数量，而且必须保证总额还是不变的，那就势必要增加后面的面额的钱的数量，而且1张大面额钱 = n张小面额钱，前面减少了t张大面额，后面就要增加 n*t 张小面额，n*t大于1，则整体加起来，钱的数量一定是变大了，所以上面解法中就是最优的解法了。

   > 这里每个面额的钱都是不限量的，换个情况，每个面额的钱都是限量的，但是保证最后可以找够钱，那上面的解法依然有效。因为只要前面的钱少了一张，后面的钱就要多出好多张，整体上就增加了钱的数量，不是最优解。

3. 机器调度问题

4. 0/1背包问题，很经典，背后是个很复杂的问题。

5. 拓扑排序

5.1 顶点活动问题 AOV activity on vertex

一个有向图，顶点处会发生一些具体的事，有向边 (i,j) 表示顶点 i 处的事件必须在顶点 j 处的事件之前发生，（强调一个先后顺序问题，而不是说 i 处发生完之后下一个就必须发生 j），对于图中各顶点的事件，确定一个发生的合理顺序。（这个顺序可能不唯一）

这个问题的求解策略是：用一个数组来表示待确定的拓扑序列 list ，一个图来表示所有的顶点和边。不断的循环（直到所有的点都入 list 了），每次从剩下的顶点中选出一个顶点 w，其中对于它所有的入边(v,w)，v都已经在 list 里了（表示已经在w之前完成了）。如果选不出来，那就跳出循环，然后判断是不是list.length == graph.vertex.length。如果是就能得出一个有效的拓扑序列，如果不是就得不出。

如果有向图中有环，那肯定没有拓扑序列，因为对于环来说，没法确定到底最开始先干哪个

5.2 边活动问题 AOE activity on edge