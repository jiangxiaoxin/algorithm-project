# 二叉树

## 完美二叉树

所有的节点中，除了~~最后的~~叶子节点，其他的节点都是满的(左右子节点都存在),这样的树叫完美二叉树(perfect binary tree)，也叫满二叉树(full binary tree)。

完美二叉树基本很难遇到，也没啥太多的应用场景。

## 完全二叉树 complete binary tree

所有的节点，从上到下，从左到右，按照这个顺序来判断，除了最后的叶子节点，其他的节点中，前面的靠左的节点都是满的(左右子节点)，只有最后的节点可以是不满的。完全二叉树是一种非常重要的二叉树。[ps:这是我自己的理解，书上的定义是根据完美二叉树来的]

二叉树的节点深度：从这个节点出发到根节点结束，会有一条路径，这条路径上“线段”的个数

## 二叉树的操作

### 创建一棵符合要求的二叉树

### 遍历一棵给定的二叉树

1. 先序 preOrderTraverse 根、左子树、右子树
2. 中序 inOrderTraverse 左子树、根、右子树
3. 后序 postOrderTraverse 左子树、右子树、根
4. 层次遍历 levelOrderTraverse 按照层次遍历，从上往下，从左往右

> 是先序、中序、后序的哪一种，只要看根节点遍历的位置：**先遍历的先序，后遍历的后序，中间遍历的中序**

### 非递归地遍历

### 递归的遍历

### 判断两颗二叉树是否“同构”：**递归**

同构：如果两棵二叉树，通过有限次的交换节点的左右子节点后，两棵树变成一样的，那这两棵树就是同构的。

### 翻转一棵二叉树：遍历节点，交换左右节点，然后递归遍历新的左右子树
