# 红黑树

一棵满足特殊要求的二叉搜索树（也叫二叉查找树，都一样）。

在构建二叉搜索树的时候，有一个显而易见的问题，就是如果构建的树深度太深，大部分的元素值都已经快在一条线性链了，那其查找的性能就会差很多。所以构建一棵较平衡的二叉搜索树就变得很重要，也就有了红黑树。

一棵很差的二叉查找树示例：  
![线性链](./img/线性链.png)

### 红黑树的性质：

1. 树中节点要么是黑色，要么是红色
2. 树的根节点是黑色
3. 如果一个节点是红的，那它的两个子节点必须是黑的。也就是说，树中父节点和其任意一个子节点，不能连续为红色。虽然不能连续是红色，但可以连续是黑色。
4. 一棵树总归会有最后的叶子节点，它们没有子节点了，但红黑树我们扩展了一下树，在原来的叶子节点上，给它补齐左右两个“子节点”，我们叫 nil节点。nil节点是黑色的。
5. 一个节点Z，从它子节点开始到它子树的最终的 nil节点，每一条这样的路径上，其黑色节点数量都是相同的。(就叫黑高吧，多简单)。我们选择一个黑色的节点，计算这个节点的黑高时，是不算它自己本身的，从子节点开始。

> 1. nil节点虽然是添加的辅助节点，但它也有颜色，是黑色的。
> 2. 在计算某个节点子树的路径上黑色节点数量时，nil节点是算在内的。
> 3. 在构建的红黑树内，所有的节点，都有两个子节点，不足的用 nil节点去补足。

![红黑树的例子](./img/红黑树的例子.png)

> 有的地方，把树原来的真实节点叫树的内部节点，把加上去做辅助作用的 nil节点叫外部节点，我反正觉得没啥特大的意义，添加那么多概念干嘛呢。我习惯把添加的 nil节点就叫做叶子

### 红黑树的操作：

#### 旋转：对于一棵红黑树，以某个节点为基准，进行旋转。旋转后只是交换了x y节点的位置，可以看作把y的位置下调了，或者把x的位置提升了。

![红黑树的旋转](./img/旋转.png)

上图中，将红黑树进行了简化，节点x y的子支用字母代替，可以是真实的节点，也可以是nil节点。  
旋转不是一个可以单独使用的操作。因为旋转之后并不能保证新树依然满足红黑树的要求。比如图中右旋之后，x与它新的父节点都是红的，或者x y的黑高不一致了。

#### 插入

往一棵红黑树里插入一个新的节点 Z，先按照类似二叉查找树的方式找出要插入的位置，然后把插入的节点颜色设置为红色。但这样就有可能造成根节点不是黑色或者有连续两个红色节点，所以后续要有一个修正的步骤。  

> 插入的新节点结构一定是一个Z节点再加它的左和右子节点，并且两个子节点都是 nil节点。为什么呢？ 
> 因为按照二叉搜索树的插入方法，新插入的节点Z，它的位置一定是原来树的“最末支”。

![红黑树插入](./img/红黑树插入.png)  
上图只是按照二叉搜索树的要求去找个位置插入Z，但这样子并不能保证满足红黑树的性质。必须对Z进行修正。 
而且只是举一种情况来考虑，并没有把所有的情况都列全了。

#### 如何修正插入的Z节点？？

> 红黑树的修正，我们基于一个最基本的前提：  
> 原树本来就是棵红黑树，这一点肯定能保证，不然就不叫红黑树的插入了.既然是棵红黑树，那就是说树遵守红黑树的性质，这一点非常重要.树中所有的节点都有两个子节点，没有的用 nil节点补齐。当然，nil节点是没有后续节点的。

基于这个前提，我们开始分析红黑树如何修正节点

1. 如果插入后，节点z是根节点  
> 就是说，在z节点插入之前，树是空的，这种情况简单，只要把z的颜色改成黑色，就满足所有的要求了。  

2. 如果插入的是其他节点  

![红黑树的修正](./img/红黑树的修正.png)

2.1 假设z节点的父节点p是黑色的，那么就会有下面这几种情况：

2.1.1 如图a，p 在原树里是末支节点了，两个节点都是nil节点，只要找到z是左还是右就可以了，插入z后就满足要求  

2.1.2 如果p的两个节点不都是nil节点

(1)假设有一个nil节点，分析左还是右是一样的。

假设左节点是nil，右节点不是。图b  
根据条件5得到，p的黑高是1，因为只有一个nil节点，那么p的右支也要是1个黑节点才行。而不管怎样，右边节点树最后肯定有nil节点，它是黑的，所以中间不能再有黑的节点，不然就超过1个了。那就得出中间节点应该都是红色的，而如果都是红色的。那将违反“红色的节点孩子必须是黑色的”，所以在p的左节点是nil，而右节点不空的情况下，那就只能是图b那一种情况，p的右支其实只有一个真的节点，并且是红的，而且该节点有两个nil节点

在上面分析出只能是图b这种情况下：

（1.a）假设z插入的是p的左支，那就是简单的插入就可以了，插入后满足所有条件。直接变成图i就行了。
（1.b）假设z插入的是p的右支，那就是c和d两种情况，这两种情况下，虽然能保持条件5仍能成立，但是违反了“不能有两个连续的红色节点”，需要继续做出修正

(2)假设一个nil节点都没有，就是有两个真实的节点，像图e那样

在这种情况下，z节点的位置应该沿着某条路径继续往下找的，就跟z节点插入的父节点是p节点矛盾了，所以这种情况是不存在的。

> 综合（1）和（2），如果p的两个节点不都是nil节点，那就只能是有一个节点nil的情况。在这种情况下，要修正的就变成：z是红色的，它的父节点是红的，而叔叔是黑色的，且z是左支，和z是右支两种情况（就是c和d两种情况，p已经不是z的父节点了）

2.2 假设z节点的父节点p是红色的，那么显然违反了“红色节点不能连续”这个条件，要进行修正

这种情况可以通过分析简化。

首先，我们知道，如果指定一个节点p为z插入后的父节点，那么这个p节点一定是图f或者图g（有右支，但z插入左支）那样，要么p就是末支节点，要么p还有子支。

图f那种状况，插入z后当然要修正，要不然就两个红的连在一起了。  

图g那种情况不存在的，为啥呢？因为说了要符合前提条件。p的黑色节点数是1，而右边肯定有nil节点，如果中间还有其他节点，不管有多少，如果还有黑的，那就不满足“路径上的黑色节点数是一样的”。既然不能是黑的，那就只能是红的，而如果是红的，那就违反了“两个红的不能连在一起”的条件  

所以问题就简化成图f那一种。而简化成这种后，p既然是红的，那p的父节点就肯定是黑的.

那p的叔叔节点呢？假设是黑的。显然p.p的黑节点个数是1，如果叔叔也是黑的，再算上最后肯定有个nil是黑的，那右边就是2，显然不符合条件，所以叔叔不可能是黑的。

【这里只是以第一次插入时的情况做了说明，后续在修正的过程中，再一次修正之后，会出现下面说的5中情况的一种】

不说插入的情况，而是修正过程中，一次修正结束后的新状态下：

> 红黑树其实分为下面几种情况：
> 1. 如果插入后，Z是根节点，那么原树是空树，直接把节点涂成黑色  
> 2. 如果插入后，z的父节点是黑的，那么没有违背什么条件，啥也不做  
如果z的父节点是祖父节点的左分支（这里会出现左右两种情况，不过处理是类似的）
> 3. 如果插入后，z的父节点是红的，叔叔节点是红的  
> 4. 如果插入后，z的父节点是红的，叔叔节点是黑的，而且z节点是左儿子  
> 5. 如果插入后，z的父节点是红的，叔叔节点是黑的，而且z节点是右儿子
如果z的父节点是祖父节点的右分支
> 3. 如果插入后，z的父节点是红的，叔叔节点是红的  
> 4. 如果插入后，z的父节点是红的，叔叔节点是黑的，而且z节点是左儿子  
> 5. 如果插入后，z的父节点是红的，叔叔节点是黑的，而且z节点是右儿子
> 其中1和2很简单。3，4，5需要特殊处理下
	
##### 情况3的修正

跟上面类似的分析，就取一种情况分析，【z的父节点是祖父节点的左分支】。

![修正3](./img/修正3.png)

> 1. 原树
> 2. 插入z
> 3. z的父节点和叔叔节点都改成黑的
> 4. z的祖父节点改成红的
> 5. 现在把z的祖父节点当成z
  
> 如果z节点插入后，图中p节点就是z节点的父节点，且z节点的父节点跟叔叔节点都是红色的。那么，原树中p节点的父节点一定是黑色的，不然就两个红色相连了。此时p.p的黑色节点数是2，从p.p出发的每条到“终点”的路径上都有两个黑色的节点。

> 假定z插入的是p的左支（左右一样的分析）。插入后，p和z都是红色的，这违反了规则，所以要修正。

> 把z的父节点和叔叔节点都变成黑色的。只把节点变成黑色的，不会违背“两个红的不能连在一起”的要求，但是可能违背另一个要求：从一个节点出发，它的分支的路径上黑色节点数相同。以图示情况来说，在一开始的时候，p的黑色节点数是1个，p.p的黑色节点数是2个，但是现在p仍然为1个，p.p却变成了2个。那么对于p.p.p节点来说，它的左支比原来多了一个黑节点，但是它的右支没有发生变化，这就不符合要求了，所以把z的父节点和叔节点改成红色之后要继续修正。

> 那怎么修正呢？对于情况3，把当前结点（也就是Z节点）的父节点和叔叔节点都变成黑的以后，p.p.p的左支多了一个黑节点，右支没有变，那有一种方法，就是把p.p改成红色，这样子，多了个黑色的p，少了个黑色的p.p，就维持了数目不变。而把p.p改成红色之后，又可能面对同样的问题：把p.p看成当前结点，它与它的父节点，有可能都是红色的，所以while循环进入下一次判断。如果当前结点的父节点不是红的，那就已经好了，退出while循环了，红黑树插入成功了。

【nil节点其实可以看成一个分支】

![父红叔红的一种简单情况](./img/父红叔红的一种简单情况.png)

【以上面的图示简单例子来说，对于情况3，我们先把原来的z节点的父节点和叔节点改成黑色，z的祖父节点改成红色，然后把z更新成原来z节点的祖父节点，那么对于原来z节点的z.p.p.p来说，一条路径上，多了一个黑的（原来的z.p和z的叔），又少了一个黑色（z.p.p改成了红色的），那就相当于没变化，那么对于原来的z.p.p.p，它的左右支仍然黑高一致，再往上一层继续看，节点的左右支依然黑高一致，并没有破坏规则。修正之后，唯一可能出现的就是新的节点又跟其父节点都是红的，那就继续修正】

【一次修正之后，我们会把当前结点z进行重新赋值，z = z,p.p，并继续进行修正】

【一次修正之后，使新的节点z的左右子节点树符合红黑树的要求。】


##### 情况4和5的修正

情况4和情况5类似，一个要左旋一个要右旋，就以4来说明：z的父节点是红的，叔叔节点是黑的，而且z节点是左儿子 

![修正4](./img/情况4的一种情况.png)

图中定的是z是父节点的左儿子，如果是右儿子呢？伪代码里有个先左旋的操作，左旋后情况就变成了情况4，可以按照4的来处理

![z是右儿子](./img/z是右儿子.png)


#### 红黑树插入的伪代码

![红黑树插入伪代码](./img/红黑树插入伪代码.png)

#### 构建一棵红黑树

与构建一棵二叉搜索树类似，从空树开始，每次往树里插入一个节点，插完了也就成了一棵红黑树。既是一棵红黑树，那它就是一个比较平衡的二叉查找树了，搜索性能就比较好了。
当然这在构建这棵树的过程中就要付出更多的代价了，比如更多的循环比较，节点的移动等等。


#### 删除

