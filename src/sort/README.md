
# 排序

- [x] [冒泡排序](#bubble-sort)
- [x] [快速排序](#quick-sort)
- [x] [插入排序](#insert-sort)
- [x] [堆排序](#heap-sort)
- [x] [归并排序](#merge-sort)
- [x] [选择排序](#select-sort)
- [x] [基数排序](#radix-sort)

<h2 id="bubble-sort">冒泡排序</h2>

一种最简单，最容易理解的排序方式。

从头开始，依次取出一个元素，然后跟相邻（后面）的元素进行比较，按照大小关系进行排序，这样一趟下来，经过不断的比较和交换位置，最后能确定一个数字的最终位置，在最后面。既然每排一次就能确定一个数字的位置，那就重复数组的长度次，那数组就是有序的了。

当然，在取元素跟相邻比较的过程中，后面的元素慢慢就是有序的了，没有必要后面这部分元素每次还要遍历比较下，可以跳过。这样能减少比较的次数，提高速度。但这并不影响整体的时间的数量级。

对于简单的排序情况，冒泡就足够了。速度不见得太低，逻辑又简单，容易记忆，容易写。

<h2 id="quick-sort">快速排序</h2>

快速排序是对冒泡排序的一种改进方式，以从小到大排序为例，它一次步骤完成，确定一个`index`值，将考察范围内的数组元素分为3部分，`left -> index-1`,`index`,`index+1 -> right`，这3部分满足index前的元素值都比index小，index后的元素值都比index大，这样这3部分就**基本有序**，然后递归处理前面部分和后面部分，使得每个考察的数组都变得**基本有序**，直到将要考察的元素拆分为2个或者3个时，仍然满足**基本有序**，则从底往顶退回时就能保持**完整有序**。

<h2 id="insert-sort">插入排序</h2>

原理也很简单，就类似打牌时抓牌，每次抓一张牌，然后在手上的牌堆里找到要插入的位置，然后插入这张牌。如此循环直到没有待插入的牌，整手的牌就有序了。在确定要插入的位置时，有不同的方法。如果用数组实现，插入后，还要面临一个问题，就是插入位置后的元素要往后移动，才能空出位置插入待插入的元素。

<h2 id="heap-sort">堆排序</h2>

为了解决选择排序中，使用树形选择排序时的问题，提出了堆排序。

<h2 id="merge-sort">归并排序</h2>

先分拆开，知道拆开的只有2个元素，这2个元素比较大小排好序后，再递推回来，将两个有序的序列合并成一个有序的序列。双指针。

归并排序的递归写法简单，但是递归通常性能不怎么样，最好用非递归的.

<h2 id="select-sort">选择排序</h2>

有点像插入排序的反着来。从备选项里找出最小的数，放到最前面。然后从剩下的数里，再找出最小的数，放到第2个位置。依此类推下去，当把第n-1个数确定好位置之后，就剩下第n个数字，直接添加到最后就行了。

整体的逻辑很简单，能提升的就是如何在数组里，找出i位置之后的所有元素里的最小数。

<h2 id="radix-sort">基数排序</h2>

前面的排序是对一堆数字进行排序，排序的标准都是唯一的，就看谁大谁小。基数排序适合多关键字排序，比如收拾扑克牌时，希望最后牌面大面上是按照花色先来排一波，然后同样花色的里面再按照牌数字大小排列。
