# [外部排序](http://c.biancheng.net/view/3452.html)

将数据按照条件限制来进行分块，使得每个块可以被一次性载入内存，然后对每一块内部进行排序。载入一块，排序一块，然后保存到硬盘。等所有的块都排序好后，再将这些排好序的块归并到一起，则整体有序。

对于分好的块进行排序，没什么特殊的，就是用之前的内部排序的方法。那如何进行归并呢？

对于每个块，每次读入不同块里的一个数据，这些数据组成一个待考察的集合，排序得出其中最小的（假设从小到大排序），那这个最小的就是所有数据里最小的，然后写入外部文件。写入后，再读取一个数据进来，重新将待考察集合排序后得出最小值，再次写入文件。依此类推，直到最后将所有的块的数据全部处理完，写入文件。

但这里读入和写入文件是个关键，一次读入10个数据，和一次读入1个数据，所耗时并不是10倍的关系，可能是100倍，1000倍。所以如何在内存限制的前提下减少读入和写入文件的次数成了关键。

在第一次比较时，几个数据排序好，选择出最小一个“写入文件”后，再取一个填补进来。由于前面的数据都是有序的，那填补进来后并不需要完全的重新排序，可以二分查找快速确定位置。确定位置后数字集的最前边的就是下一个要弹出的最小值。

**外部排序的关键是针对限制条件，如何确定合适的分块，已经如何从已排序好的分块里重新合出最后的排好序的整体**

归并操作对象的选取有两种方式：一是根据限制，每次选取两个归并段作为操作对象，从中读入一部分数据，然后对这部分数据进行归并，归并完后写入文件。再读一部分数据进来，执行一样的操作。处理完这俩归并段之后，再取俩归并段进行一样的操作。或者同时开启几个归并段，但是相对来说，每个段读入少量的数据，归并处理完后，写入文件。再每个归并段读入一部分数据，再进行同样的操作。针对这两种方式就出了**n-路平衡归并**的概念。

## 2-路平衡归并

**2-路平衡归并**是先分段，对每段进行段内排序。归并时，选取两段为对象，一部分一部分合并，比如 R1 和 R2 合并，R3 和 R4 合并，合并完后又得到一些归并段，再继续同样的操作，直到把所有的数据都归并起来。它的执行过程像是倒过来的二叉树一样，一层一层，段的数量不断减少，最后合成一个“根节点”，完成排序。

## 多路平衡归并

**n-路归并**意思是，在完成段内排序后，要归并成整体有序的数据，在这个归并的过程中，一次选取的归并段的数量。每次选2个就是2-路，每次选3个就是3-路，依此类推。

使用**败者树**策略进行归并。

分路平衡归并时，在归并的过程中，操作的对象是已经内部有序的子段，限制条件依然是内存不足以一次性载入所有数据。那设置合理的缓冲区buffer，举例来说，假设内存限制最高200条数据，4-路合并，那就从4个子段，每段读入50个数据，总共有200个数据，内存能装得下。进入内存之后，这些数据依然有明确的标识都属于哪个段里。归并的过程中，不断的将目标从这200个数据里选出来。假定这载入内存的4块数据中有一块空了，则此次归并暂停。总有一块会先取空的。当某块取空后，此时将buffer内的数据写入文件，这些数据的大小关系是正确的，且对于整体数据来说也是正确的。然后从块里再读入一些数据，每个块读入的数据就是每个块已经写出去的数据的数量。

参考链接里，在归并的过程中，只说了将谁和谁要进行归并，但没进行怎么归并的说明，因为随着归并的操作，后面的一块数据的数据量越来越大，不可能一次性载入内存了，如何将800个数据和200个数据归并？就是我上面说的，设置buffer，减少读写的操作。

**对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多**

因为归并操作次数越多，说明一开始分的块越多，同样的总和数量下的数据，每块就越小，但是每块的读入依然是要一次读入操作的，那就意味着读入操作越多。

一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：s=⌊log<sub>k</sub>m⌋（其中 s 表示归并次数）。

## 置换-选择归并

## 最佳归并树

