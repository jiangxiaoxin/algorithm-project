# 6.堆排序

#### 二叉树：

维基百科：https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91

一个树的高度或者深度，是计算它的“长度”最长的“边”由几条“线段”组成。
下面图示的满二叉树，深度/高度为3，因为边最长只构成3条线段

![满二叉树](./img/full-binary-tree.jpg)

满二叉树：除了最底层的叶子节点，其他所有的层上的节点，都有2个子节点的二叉树。满，就是填满，充满的意思。

完全二叉树：从对应的满二叉树里劈下一块，最后一层的节点都尽量靠左排列的二叉树。

![完全二叉树](./img/complete-binary-tree.gif)

从两个图看，满二叉树肯定是颗完全二叉树，但是完全二叉树不一定是满二叉树

关于这俩定义，还真有点疑问：网上的定义还都不一致，说分国内定义和国外定义。
有种说法叫：除了叶子节点，其余的节点都有2个子节点，这就叫满二叉树。那么如果按照这个定义来看，下面的二叉树也算个满二叉树

![一棵二叉树](./img/tree-img.png)

蓝色的节点是叶子节点，出了它们就只剩下1和2，但是剩下的节点1和2，它们是满的。那难道上面这是个满二叉树？但这个又感觉上好像并不是呀。

！！！ 上面的树不是满二叉树。满二叉树只有最后一层是叶子节点，其他层都是有2个子节点才行。
满二叉树的定义不是说“除了叶子节点，其他的节点都有2个子节点”，而是按照公示，如果一个二叉树，其深度为 K，那么其子节点个数满足下面公式,则为一个满二叉树    
![公式](./img/fomula-1.png)  

深度或者说层数，根节点不是第1层，是第0层。

![tree-img-2](./img/tree-img-2.png)

维基百科上讲： 对任何一棵非空的二叉树，如果其叶片（终端节点）数为n0，分支度为2的节点数为n2，则n0=n2+1。
针对上图，n2 肯定是2，那么由公示 n0 就肯定是 3， 所以节点3也是叶子节点才行，也就反证出，上面“满二叉树是除叶子节点外其他节点都有2个子节点的数”这个说法并不正确。

那完全二叉树其实就是，除了最后一层，其余层都是满的。上面这个图，除了第2层没有填满，还缺2个，第1层最多就放2个，满了，第0层就只能放根节点1个，也满了，所以上图是颗完全二叉树。


link：
https://medium.com/basecs/heapify-all-the-things-with-heap-sort-55ee1c93af82

#### 堆

堆可以用完全二叉树来表示。堆排序就是一个数组A，[a0, a1, a2,....an]这么表示，然后从开头a0开始取出值，一个一个去构建一棵完全二叉树，然后对这课完全二叉树进行排序。


下图展示了将一个数组转化成对应的完全二叉树。图中的序号是从1开始，与实际代码中开始序号不同。
![将数组转化成一个完全二叉树](./img/array-to-tree.png)

最大的在前面就是最大堆，最小的在前面就是最小堆。


最大堆，父节点大于等于子节点的值。最小堆：父节点小于等于子节点的值。一般用的时候，不考虑等于的情况。


`max_heapify`将传入的数组，从i开始整理成符合最大堆原则的数组，但是有前提条件的，那就是从i开始剩下的那块树都已经满足左树和右数是符合原则的，并不是随便给一个array和i，都能最后构建最大堆，真正能构建最大堆是`build_max_heap`.

那怎么构建最大堆呢？

一个数组，有10个元素，那它对应的堆的表示方法就如上图，红色表示元素对应的下标。

1. 最后的叶子节点 5 6 7 8 9，因为它们都没有子节点了，所以它们天然已经满足最大堆原则，可以直接跳过。
2. 倒数第二排，从有子节点的 4 开始
3. 第1步里说明了，9 是符合原则的，那么这时候就适用 max_heapify 的情况了，给定一个父节点和满足原则的子节点，那就可以进行处理，让它们符合原则
4. 然后到了下标 3，再用 max_heapify，将它和它的子节点处理一下
5. 从下往上依次处理，最后就构建了一个最大堆

为什么这样就能构建最大堆？

关键就是 `max_heapify` 的前提条件要求左右子节点满足原则。  
1. 父节点的值比左右子节点大，那么就不用处理，父节点连同子节点树就已经符合原则了
2. 父节点的值不是最大的，那么左右其实一样的分析.  
经过两个 if 比较找出最大的了，假设是左最大，那么父跟左交换位置，显然新的父 左 右 满足原则。右因为没有任何变动，右边剩余的都符合原则。
现在的新左，因为是刚修改的，并不能保证就比此时新左的左和右节点大，那么就需要再次比较。而这个比较的过程正好就是 `max_heapify` ，所以只要递归使用 `max_heapify` 就行了


##### 堆排序

构建完最大堆之后，数组中最大的元素就在根部，但是此时堆只是保证在所有的局部，父节点都是比子节点大，并不能保证子节点之间的大小关系，此时数组还没有排序完。

构建完最大堆之后，把A[0]的值跟A[length-1]的值交换，那么最大的数就在最后了。但是交换后，原来最后的数就变成了根部，此时并不能保证它就是最大的。怎么处理呢？
交换后，把尾部的数从堆中去掉，然后此时问题就变成了，一个根元素，不知道是不是最大，一个满足原则的左节点树和一个右节点树，怎样处理让这些数中最大的值到达根部？
很显然，这又是 `max_heapify` 要处理的问题。

#### 优先级队列

利用最大堆和堆排序相关知识可以构建一个优先级队列。每个“任务”都有一个对应的优先级，每次都从队列中找出一个优先级最高的，拿出来去执行。

```
build_max_heap(array) // 构建最大堆。如果array确定是已经构架好最大堆了，那 heap_maximum 直接return array[0]即可，否则就要先构建最大堆
```

下面的几个方法，都要提前构建过最大堆才能用

```javascript
// 访问当前优先级最高的数据。
heap_maximum(array) {  
  return array[0]
}
```

```javascript
heap_size = array.length
// 从数组中返回最大优先级，并重新构建好剩余的数据
function heap_extract_max(array) {
  max = array[0]  // 前面构建了最大堆，那么max = array[0]

  array[0] = array[heap_size] // 把 heap_size 下标的元素换到 0 处，这跟 heap_sort 是类似的

  heap_size = heap_size - 1

  max_heapify(array, 0, heap_size) // 重新构建剩余优先级的最大堆，之后最大优先级又到了 0处

  return max
}
```

```javascript
// 提升下标 i 的优先级，变为新的 priority。只能是提升，新的优先级比原来的高
heap_increase_priority(array, i, priority) {
  array[i] = priority // 先更新优先级
  parent = PARENT[i]  // 然后与其父节点比较
  while(i > 0) {
    if (array[parent] < priority) { // 如果优先级比父节点高，就交换值。因为之前已经构建最大堆了，所以父节点交换后跟下面的节点仍然满足最大堆要求，但是新提升的优先级不一定满足要求，所以要沿着路径递归的去比对，一直到根节点。
      exchange array[parent] with array[i]
      i = parent
    }
  }
  
}
```


```javascript
// 添加新的优先级数据
// 先给队列加一个负无穷的优先级，直接添加到最后，一定满足最大堆的要求，它前面的肯定比它大，毕竟是MIN_VALUE。新元素下标为 heap_size-1 
// 问题就变成了，将最后的那个优先级，提升至新加的 priority 的问题，也就是 heap_increase_priority
max_heap_insert(array, priority) {
  heap_size = heap_size + 1
  array[heap_size-1] = - infinity // MIN_VALUE
  heap_increase_priority(array, heap_size-1, priority)
}
```