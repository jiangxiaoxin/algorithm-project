# 插入排序

类似打牌时排列牌的顺序，假设前面的都是已经排好序的，只要找出当前牌要插入的位置，然后把牌插进去即可。在找当前牌应该插入的位置时就有技巧了，可以从头挨个测试，也可以折半查找，也可以从后往前找。从前和从后找基本属于一致的，所以最好能折半查找，这样子效率更高。但是否能折半也要看具体的存储结构，如果用数组来存，那可以直接折半求出序号。如果是用链表来存，那就没有序号这一说，就不能折半了。

```javascript
// 从小到大排列
export default function sort(nums: Array<number>) {
  if (nums === null || nums === undefined) {
    return
  }

  for (let j = 1, length = nums.length; j < length ;j++ ) { // 处理[0]牌时，手里还没有牌，所以它就是已经排好序的，直接放入手中即可。所以我们从[1]牌开始
    let key = nums[j]
    let i = j -1
    while(i>=0) {
      if (nums[i] <= key) { //假定前面的牌都是排好序的，所以如果要插入的牌[j]比前面的牌[i]大，那就不需要查找位置了，[j]的位置就是j，是准确的，跳出这次循环
        break
      }
      // 否则表示[i+1]的位置不对，要给它找出正确的位置
      // 这里是一边比较挪动，也可以先判断出要放到哪里，然后再挪动
      // 但这里的方法有个好处，就是遍历的过程中，就已经往后挪了，而不需要结束后再统一挪的那次for循环，循环上少了
      nums[i+1] = nums[i] //因为从小到大排列，所以[i]处的值要往后移动一次
      i = i-1 // 然后i往前退一位，继续跟要插入的值比较大小
      console.log('交换值:', nums.join(','))
    }
    nums[i + 1] = key // 跳出循环之后，key就是要插入的值，[i]就是比key刚好小的那个值，所以i+1就是key的位置，给这个位置赋值即可
    console.log('当前值：', nums.join('_'))
  }
}
```

大的逻辑是不会变的，可以改变的就是如何发现要移动的位置，以及如何移动

1.普通的遍历寻找，遍历移动。可以先寻找，再移动。也可以边寻找边移动，上面那样，可以减少一次遍历

2.二分查找，遍历移动

3.2-路插入排序

4.表插入排序.就是构建个循环链表，但各个元素存还是存在数组里的，每个元素有个值域和指针域，指针域记录下一个值在数组中的 index

表插入排序只是将顺序排好了，还不能随意的访问（就是我想知道第i大的数是谁就直接取到），需要对得到的循环链表再进行处理才能得到按顺序排列的数组元素