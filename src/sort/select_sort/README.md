# 选择排序

**简单选择排序**，每次执行`findMinNumIndex`去找剩余元素中最小的元素。时间复杂度：`N^2`

```js
function selectSort(array) {
  for(var i=0;i<length;i++) {
    var index = findMinNumIndex(array, i);
    if (index !== i) {
      // 如果找出来的index和i不一样，说明这个元素放的位置不对，它是第i大的数，就应该放到i的位置
      swap(i, index);
    }
  }
}

// 核心的部分怎么从一堆元素里找出最小的那个
function findMinNumIndex(array, i) {
  // 找出数组里，从i开始到最后的元素中，值最小的
}
```

如何找出一堆元素里的最小的元素？

可以进行一次遍历，取最前面的为 min，在遍历中比较，更新 min的值，最后遍历完就确定这一趟遍历中，所有元素里的最小的元素。但这样子有点像冒泡排序。冒泡排序遍历一次，能确定一个元素的位置，放到数组的最后。选择排序如果采用这里描述的方法，其实质跟冒泡是一样的，确定一个数的位置，只不过放到开头的地方了，而冒泡是放到数组的结尾。

**树形选择排序**，将数组元素两两分组，然后开始比较，从中选出每对之中较少的，然后在由这选出的元素组成的数组中，再两两分组，再提取小的数组成新的数组，再循环下去，直到到达“树的根”，得出这一轮中数组元素中的最小值。然后将数组中这个最小值对应的值改成无穷大，再来这么一轮，就得出第二小的 ，在将其改为无穷大，再进行下一轮。每轮比较之后，都能得出此时的最小的元素，所以进行 n 轮后也就能得出正确的顺序了。但这个法要不断的分和记录当前比较数组，使用额外空间多。时间复杂度：`N*logN`。

为了优化树形选择排序，提出了堆排序。